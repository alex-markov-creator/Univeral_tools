Install (root) packages git:
==================================================
sudo apt-get install git git-doc gitweb \
git-gui gitk git-email git-svn

Preferences git for linux
==================================================
Edit file - .bashrc:
-//-file 
export EDITOR=vim
export GIT_EDITOR=vim
export GIT_AUTHOR_NAME='andrew.bezzubov'
export GIT_AUTHOR_EMAIL='agb2019@list.ru'
-//-file

БАЗОВЫЕ ПОНЯТИЯ:
----------------

New repositary
================================================== 
git help --all # commands help
git --version # git version
git help <subcommand> # subcommand help

**************************************************
ЗАПОМНИТЬ!!!
Используйте двойное тире, чтобы отделить часть
управления коммандной строки от списка операндов,
например, от имени файлов:
git diff -w master origin -- tools/Makefile
Двойное тире нужно использовать, чтобы разделить и
явно идентифицировать имена файлов, если иначе они
могли бы быть приняты за другую часть команды.
Например:
git checkout main.c # проверка тега
git checkout --main.c # проверка файла
**************************************************

git init # create git repository
git add <file> # add file
git add . # add all files
git status #status index
git commit -m "TEXT COMMIT" --author="NAME"

**************************************************
ЗАПОМНИТЬ!!!
Если вы не конфигурировали свое имя и e-mail, так
чтобы они были доступны в Git, это может стать
причиной некоторых предупреждений.:)
**************************************************

git commit <file> # open GIT_EDITOR
git log # preview comments
git show <identification comment> # more info
git show-branch --more=10 # preview 10 strings
git diff <identification_1> <identification_2>
git mv <name> <name> # rename file

**************************************************
ЗАПОМНИТЬ!!!
Исследовать различия между командами:
ls -lsa <dir> <dir2>
diff -r <dir> <dir2>
**************************************************

git config --global user.name "<name>"# name user
git config --global user.email "<email>" # email
git config user.email "<email>" # no global email
git config -l #preview config

**************************************************
ЗАПОМНИТЬ!!!
Параметры репозитория:
cat .git/config
**************************************************

git config --unset --global user.email # delete

**************************************************
ЗАПОМНИТЬ!!!
Настройка псевдонимов:
git config --global alias.show-graph \
'log --graph --abbrev-commit --pretty=oneline'
**************************************************

БЛОБ - содержит данные файла внутреняя структура 
которого игнорируется программой и не содержит
метаданные о файле.

ДЕРЕВЬЯ - один уровень информации каталога.
Записывает идентификаторы блобов, имена путей и
немного метаданных для всех файлов в каталоге.
Может рекурсивно ссылаться на другие 
поддеревья. Используются для построения полной иерархии
файлов и подкаталогов.

ФИКСАЦИИ(КОММИТЫ) - хранят метаданные для каждого
изменения в репозитории, включая имя автора, дату
фиксации и сообщение журнала. Указывает на объект дерева,
который захватывает в одном полном снимке состояние 
репозитария на момент осуществления фиксации. 
У начальной фиксации нет родителя.

ТЕГИ - объект тега назначает человекочитаемое имя 
определенному объекту, обычно фиксации.

ИНДЕКС - временный и динамический двоичный файл,
который описывает структуру всего репозитария. 

ИНДЕКСЫ
-------
**************************************************
ЗАПОМНИТЬ!!!
Доступ к содержимому файла:
git cat-file -p <хэш-код>
Поиск объектов по префиксу хэша:
git rev-parse 3b18e512d
Просмотр содержимого индекса:
git ls-files -s
Объект дерева:
git write-tree
Объект фиксации дерева:
git commit-tree
Пример:
echo -n "<Commit>" | git commit-tree <identification>
Анотированный тег:
git tag -m "<text tags>" <name> <identification>
Найти объект тега:
git rev-parse V1.0
git cat-file -p <identification>
**************************************************

git status # файлы подготовленные для фиксации
git diff # изменения в рабочем каталоге но не в индексе
git diff -cached # изменения в индексе

**************************************************
ЗАПОМНИТЬ!!!
Игнорирование файла:
echo <name ignored file> > .gitignore 
Хэш файла:
git hash-object data
Интерактивный режим для команд git add и git commit:
--interactive
Фиксация всех файлов:
git commit -a
Удаление файла из индекса после фиксации:
git rm <file>
Файл в неотслеживаемые после добавления git add:
git rm --cached <file> ОСТОРОЖНО!!!КОПИЯ ОСТАЕТСЯ!!!
Принудительное удаление файла:
git rm -f
**************************************************

git mv <file1> <file2> # переименовать файл
git log <file2> # логи о переименовании 
git log --follow <file2> # все логи
 
КОММИТЫ(ФИКСАЦИИ)
-----------------
**************************************************
ЗАПОМНИТЬ!!!
Уникальный префикс:
git log -1 --pretty=online HEAD
git log -1 --pretty=online <preffix>
Технически, имя каталога Git(.git) можно изменить.
Поэтому документация Git использует переменную окружения 
$GIT_DIR вместо имени каталога .git.
Ссылки:
HEAD, ORIG_HEAD, FETCH_HEAD, CHERY_PICK_HEAD
и MERGE_HEAD - ссылки в .git/refs/remotes/ref/
master^^, master~2 - относительные имена фиксации.
*************************************************

git show-branch --more=35 
git rev-parse master
git show-branch --more=35 | tail -10
git rev-parse master~3^2^2^

**************************************************
ЗАПОМНИТЬ!!!
История фиксаций:
git log master
git log --pretty=short --abbrev-commit master~12..
master~10
git log -1 -p <prefix>
git log --pretty=short --stat master~12..master~10
Выбор фиксаций:
git log ^dev ^topic master # игнорируются dev и topic
***************************************************

gitk # graph preview

Изоляция определенной, дефектной фиксации на основе 
бинарного поиска:
----------------------------------------------------
git bisect start
git bisect good <commit or tag>
git bisect bad <commit or tag> 
and more...
git branch
git bisect reset
git branch
----------------------------------------------------

Идентификация конкретной фиксации:
----------------------------------------------------
git blame <option> <file>
git blame -L 35, <file>
----------------------------------------------------

Использование Pickaxe:
----------------------------------------------------
git log - Sinclude --pretty=online --abbrev-commit <file>
поиск в истории дельт файла заданной строки.

ВЕТКИ
-----
Тег - статическое имяб которое не изменяется и не перемещается 
в течение долгого времени.
Ветка - это динамический объект, который перемещается 
с каждой фиксацией.
Для поддержки масштабируемости можно содать иерархическое 
имя ветки, например, bug/pr-1023 и bug/pr-17.

git show-branch 'bug/*' - все ветки в bug

Правила наименования веток:
---------------------------
git check-ref-format --branch <name branch>

git branch ветка [начальная фиксация]- новая ветка

git branch -a - просмотр всех веток
git show-branch - просмотр веток с фиксациями

git checkout <name branch> - переключение ветки

Возможны конфликты при переключении веток с 
незафиксированными изменениями!!!

Объединение изменений в другую ветку:
------------------------------------
git checkout -m <name branch>

Создание новой ветки и переключение на нее:
-------------------------------------------
git checkout -b <new_branch> <begin point>
git checkout -b <new branch> HEAD - отсоединение головы

Удаление ветки:
--------------
git branch -d <name branch> - не текущая ветка!!!

**************************************************
ЗАПОМНИТЬ!!!
Пример слияния из удаляемой ветки и удаление:
git merge <name branch>
git show-branch
git branch -d <name branch>
git show-branch

После случайного удаления ветки или другой ссылки 
вы можете восстановить ее - git reflog, git fsck,
gc.reflogExpire и gc.prundeExpire. 
**************************************************

РАЗЛИЧИЯ
--------
*************************************************
ЗАПОМНИТЬ!!!
diff -u <file1> <file2> - Unix command
diff -r -u <><> - рекурсивный обход по каталогам
************************************************

git diff - показывает разницу между вашим текущим
каталогом и индексом.
git diff <фиксация> - различия между вашим рабочим 
каталогом и указанной фиксацией.
git diff --cached фиксация - показывает разницу
между подготовленными в индексе изменениями 
и заданной фиксацией.-staged - синоним. 
git diff фиксация1 фиксация2 - показывает разницу
между двумя произвольными фиксациями, игнорирует 
индекс и рабочий каталог. Поддерживает синтаксис
двух точек - git diff фиксация1..фиксация2.

--M - обнаруживает переименования файлов
-w или --ignore-all-space - игнорирование пробелов.
--stat - статистика относительно разности между
двумя состояниями дерева.
--color - раскрашивает вывод.

Команда log оперирует с набором фиксаций, а diff
сравнивает две разные конечные точки!!!
Например: 
git log -p ветка1..ветка2 - фиксации, которые
есть только в ветке2!!!
В таких случаях лучше использовать git diff!!!

git diff --stat ветка~5 ветка Documentation
-ограничение вывода только с изменениями в документации.

git diff -S>>строка ветка~50 - производит поиск последних
50 фиксаций.

СЛИЯНИЯ
-------
Пример слияния:
git checkout branch - переключаемся на ветку branch
git merge other_branch - слияние новой в текущую.
Подготовка к слиянию:
---------------------
Важно начинать слияние с "чистого" каталога и индекса!!!
(т.е. без изменений в файлах и выполненных команд git add
и git rm)
Объединение двух веток:
-----------------------
Пример:
git init
git config user.email "..."
git config user.name "..."
cat > file
....
....
git add file
git commit -m "..."
...
git checkout -b alternate master^
git show-branch
cat >> file
git commit -a -m "..."
git checkout master
git status
git merge alternate

Ваша текущая ветка всегда является целевой веткой!!!

git log --graph --pretty=oneline --abbrev-commit 
просмотр графа фиксации

Слияние с конфликтом
--------------------
Из целевой ветки:
git merge <branch>
СООБЩЕНИЕ О КОНФЛИКТЕ!!!
РЕДАКТИРОВАНИЕ ФАЙЛОВ!!!
git add <отредактированные файлы>
git commit
git show-branch
Все ветка смержена!
 
Работа с конфликтами слияния
----------------------------
СООБЩЕНИЕ О КОНФЛИКТЕ!!!

Обнаружение конфликтных файлов
------------------------------
git status
git ls-files -u

Исследование конфликтов
-----------------------
МАРКЕРЫ СЛИЯНИЯ <<<<<<<<, =========
и >>>>>>>> - генерируются автоматически.
ЗАМЕНИТЕ ЭТИ МАРКЕРЫ СОБСТВЕННЫМ ТЕКСТОМ
ДЛЯ РАЗРЕШЕНИЯ КОНФЛИКТОВ.

Сравнение HEAD и MERGE_HEAD:
git diff HEAD
git diff MERGE_HEAD

**************************************************
ЗАПОМНИТЬ!!!
git diff показывает только те секции файла, которые
еще конфликтуют, используйте эту команду для
отслеживания конфликтов, которые еще не исправлены.
**************************************************

Какие изменения откуда пришли и почему:
git log --merge --left-right -p

--merge показывает только те фиксации, которые относятся 
к конфликтующим файлам
--left-right - показывает <, если фиксация пришла "слева"
или >, если фиксация пришла "справа".
-p показывает сообщение фиксации и патчб связанный с 
каждой фиксацией.

**************************************************
ЗАПОМНИТЬ!!!
git diff :1<file> :3<file> - изменения между
базой слияния и версией из ветки, которая
объединяется с текущей
**************************************************

Завершение разрешения конфликта
-------------------------------
Будьте осторожны, чтобы не добавить (командой git add)
файлы с маркерами конфликта. Да, это очисти конфликт в 
индексе и разрешит вам фиксациюб но ваш файл не будет 
корректен!!!

Отмена или перезапуск слияния
-----------------------------
Перед выполнением последней операции git commit 
используйте команду:
git reset --hard HEAD
После завершения слияния:
git reset --hard ORIG_HEAD
Если вы испортили разрешение конфликта и хотите
вернуться к исходному состоянию конфликта, чтобы
попытаться разрешить его снова используйте:
git checkout -m

